# -*- coding: utf-8 -*-
"""
/***************************************************************************
 czech_land_use_and_CN_AnalyzerDockWidget
                                 A QGIS plugin
 czech_land_use_and_CN_Analyzer
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-07-19
        git sha              : $Format:%H$
        copyright            : (C) 2024 by CTU
        email                : jehlijos@cvut.cz
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os
import processing

from qgis.PyQt import QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal
from qgis.core import Qgis, QgsMapLayerProxyModel, QgsProject, QgsApplication, QgsTask, QgsMessageLog

from .UIupdater import UIUpdater
from .WFSdownloader import WFSDownloader
from .InputChecker import InputChecker
from .WFStask import TASK_process_wfs_layer
from .LayerEditor import LayerEditor

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'czech_land_use_and_CN_Analyzer_dockwidget_base.ui'))





class czech_land_use_and_CN_AnalyzerDockWidget(QtWidgets.QDockWidget, FORM_CLASS):
    """Dock widget class for the czech_land_use_and_CN_Analyzer plugin."""
    closingPlugin = pyqtSignal()

    def __init__(self, polygon=None, ymin=None, ymax=None, xmin=None, xmax=None, AreaFlag=False,LandUseLayers=None, parent=None):
        """Constructor."""
        super(czech_land_use_and_CN_AnalyzerDockWidget, self).__init__(parent)
        self.setupUi(self)

        self.ui_updater = UIUpdater(self.runButton, self.progressBar, self.abortButton, self.label, self.polygonButton,
                                    self.extentButton, self.polygonLabel, self.mMapLayerComboBox)

        # Initialize attributes from arguments
        self.polygon = polygon
        self.ymin = ymin
        self.ymax = ymax
        self.xmin = xmin
        self.xmax = xmax
        self.AreaFlag = AreaFlag

        self.LandUseLayers = LandUseLayers# List of LandUse layers for merge in the end

        # Set filter to map combobox to select only polygons
        self.mMapLayerComboBox.setFilters(QgsMapLayerProxyModel.PolygonLayer)

        self.extentButton.toggled.connect(self.toggle_to_extent)
        self.polygonButton.toggled.connect(self.toggle_to_polygon)
        self.runButton.clicked.connect(self.Run)

    def toggle_to_extent(self):
        self.AreaFlag = False
        self.ui_updater.ToggleChangeToExtent()

    def toggle_to_polygon(self):
        self.AreaFlag = True
        self.ui_updater.ToggleChangeToPolygon()

    def closeEvent(self, event):
        """Emit the closingPlugin signal when the dock widget is closed."""
        self.closingPlugin.emit()
        event.accept()

    def Run(self):
        """
        Run the processing.
        Starts upon clicking the Run button in UI.
        """
        QgsMessageLog.logMessage("Plugin is running.", "CzLandUseCN", level=Qgis.Info, notifyUser=False)

        self.ui_updater.reset_panel() # Reset UI elements

        self.LandUseLayers = [] # List of LandUse layers for merge in the end

        try:
            self.polygon = self.mMapLayerComboBox.currentLayer()
            self.ui_updater.LoadingMsg("Loading data, please wait...")
            # Freeze the UI elements during processing
            self.ui_updater.freeze_ui()

            # Get the list of WFS layers to process from merging config file
            config_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "config", "layers_merging_order.csv")

            wfs_downloader = WFSDownloader(config_path,self.AreaFlag, self.polygon)
            # Get info for WFS service input based on extent or polygon
            wfs_layers = wfs_downloader.get_ZABAGED_layers_list() # load WFS layers from config file
            self.ymin, self.xmin, self.ymax, self.xmax, current_extent = wfs_downloader.get_wfs_info(wfs_layers)

            # Check input by user, Qgis project settings and integrity of configuration files

            input_checker = InputChecker(self.polygon, self.ymin, self.xmin, self.ymax, self.xmax, wfs_layers,
                                         QgsProject.instance(), self.mMapLayerComboBox, self.ui_updater, self.AreaFlag)

            check_list = [input_checker.check_crs() ,input_checker.check_CR_boundary() ,
                          input_checker.check_polygon_layer() ,input_checker.check_wfs_errors()]

            if not all(check_list): # If any of the checks failed, return None
                return None

            self.progressBar.setEnabled(True)

            # Create a task to process WFS layers
            task = TASK_process_wfs_layer(wfs_layers, self.ymin, self.xmin, self.ymax, self.xmax, current_extent,
                                          self.polygon, self.AreaFlag,
                                          self.label, self.progressBar, self.runButton, self.abortButton,
                                          self.polygonButton, self.extentButton, self.LandUseLayers)


            # Connect signals from Task to update the progress bar and handle task completion
            task.progressChanged.connect(self.ui_updater.updateProgressBar)
            task.taskFinished.connect(self.TaskFinished)
            task.taskCanceled.connect(self.ui_updater.TaskCanceled)
            task.taskError.connect(self.ui_updater.TaskError)

            # Add the task to the task manager
            QgsApplication.taskManager().addTask(task)
            QgsMessageLog.logMessage("Task created.","CzLandUseCN",
                                     level=Qgis.Info, notifyUser=False)

        except Exception as e:
            if (len(str(e))) == 0:
                e = "Extent is out of Czech Republic boundaries"
            QgsMessageLog.logMessage(e,"CzLandUseCN",
                                     level=Qgis.Critical, notifyUser=True)
            self.ui_updater.ErrorMsg(f"Error occurred: {e}")
            self.ui_updater.setButtonstoDefault()
            return None




    def TaskFinished(self, layers):
        """Handle task completion(WFStask) and update LandUseLayers."""
        self.LandUseLayers = layers

        self.ui_updater.TaskSuccess()

        # Get the path to the config file with base LandUse codes and keywords for zabaged layers
        attribute_template_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "config",
                                               "zabaged_to_LandUseCode_table.yaml")

        # Get the path to the config file for ZABAGED data
        ZABAGED_config_path = os.path.join(os.path.dirname(__file__), 'config', 'ZABAGED.yaml')
        LPIS_config_path = os.path.join(os.path.dirname(__file__), 'config', 'LPIS.yaml')
        stacking_template_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "config",
                                              "layers_merging_order.csv")
        # Get a symbology (.sld) path for the final stacked layer
        symbology_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "colortables", "landuse.sld")

        layer_editor = LayerEditor(attribute_template_path,LPIS_config_path,ZABAGED_config_path, stacking_template_path,
                                   symbology_path, self.AreaFlag, self.polygon, self.ymin, self.xmin, self.ymax,
                                   self.xmax)

        # Add LandUse attribute to all layers in list
        self.LandUseLayers = layer_editor.add_landuse_attribute(self.LandUseLayers)

        # Add buffer line features to all layers in list
        self.LandUseLayers = layer_editor.buffer_layers(self.LandUseLayers)

        # Update LandUse code based on its attributes
        self.LandUseLayers = layer_editor.edit_landuse_code(self.LandUseLayers)

        # Clip all layer to the polygon or extent by AreaFlag (Used as clip after buffering)
        self.LandUseLayers = layer_editor.clip_layers_after_edits(self.LandUseLayers)

        # Stack layers with LandUse code into one
        layer_editor.stack_layers(self.LandUseLayers)

        # Show success in the UI elements after completion
        self.ui_updater.PluginSuccess()


