# -*- coding: utf-8 -*-
"""
/***************************************************************************
 czech_land_use_and_CN_AnalyzerDockWidget
                                 A QGIS plugin
 czech_land_use_and_CN_Analyzer
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-07-19
        git sha              : $Format:%H$
        copyright            : (C) 2024 by CTU
        email                : jehlijos@cvut.cz
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os
import time
import processing
from PyQt5.QtWidgets import QButtonGroup
from PyQt5.QtCore import QVariant, QCoreApplication, QUrl
from qgis.PyQt.QtGui import QDesktopServices

from qgis.PyQt import QtWidgets, uic
from qgis.PyQt.QtCore import pyqtSignal
from qgis.core import (Qgis, QgsMapLayerProxyModel, QgsProject, QgsApplication, QgsTask, QgsMessageLog,
                       QgsVectorLayer, QgsField)
from qgis.utils import iface

from .RunOffTask import TASK_RunOff
from .CNtask import TASK_CN
from .IntersectionTask import TASK_Intersection
from .SoilDownloader import simple_clip
from .SoilTask import TASK_process_soil_layer
from .UIupdater import UIUpdater, get_checked_return_periods
from .WFSdownloader import WFSDownloader
from .InputChecker import InputChecker, overlap_check, is_valid_cn_csv
from .WFStask import TASK_process_wfs_layer
from .LayerEditor import (LayerEditor, buffer_QgsVectorLayer, get_polygon_from_extent, dissolve_polygon,
                          clip_larger_layer_to_smaller, add_constant_atr, merge_layers, apply_simple_difference,
                          resolve_overlaping_buffers)
from .LayerEditorTask import TASK_edit_layers

FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'czech_land_use_and_CN_Analyzer_dockwidget_base.ui'))





class czech_land_use_and_CN_AnalyzerDockWidget(QtWidgets.QDockWidget, FORM_CLASS):
    """Dock widget class for the czech_land_use_and_CN_Analyzer plugin."""
    closingPlugin = pyqtSignal()

    def __init__(self, polygon=None, ymin=None, ymax=None, xmin=None, xmax=None, AreaFlag=False,LandUseLayers=None, parent=None,
                 SoilFlag=False, not_buffered_plg=None ):
        """Constructor."""
        super(czech_land_use_and_CN_AnalyzerDockWidget, self).__init__(parent)
        self.setupUi(self)

        self.ui_updater = UIUpdater(self.runButton, self.progressBar, self.abortButton, self.label, self.polygonButton,
                                    self.extentButton, self.polygonLabel, self.mMapLayerComboBox,
                                    self.LUandSoilSelectButton,
                                    self.SoilSelectButton, self.LUSelectButton, self.mMapLayerComboBox_LU,
                                    self.mMapLayerComboBox_HSG, self.groupBox, self.OwnRainInput)

        # Initialize attributes from arguments
        self.polygon = polygon
        self.not_buffered_plg = not_buffered_plg # for clipping after buffering in Soil process

        self.ymin = ymin
        self.ymax = ymax
        self.xmin = xmin
        self.xmax = xmax

        self.extent = None
        self.merged_layer = None

        self.AreaFlag = AreaFlag # Set AreaFlag to True > processing inside polygon
        self.SoilFlag = SoilFlag # Set SoilFlag to True > Soil type processing
        self.reset_AreaFlag = False # If creating polygon from window extent to reset the AreaFlag in end of Soil Task
        self.RunOffFlag = False  # True if User defined rainfall depth
        self.DownloadFlag = 0 # 0 == LandUse and Soil, 1 == only LandUse, 2 == only Soil

        self.LandUseLayers = LandUseLayers# List of LandUse layers for merge in the end

        self.extentButton.setChecked(True)
        self.LUandSoilSelectButton.setChecked(True)

        # Set filter to map combobox to select only polygons
        self.mMapLayerComboBox.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        self.mMapLayerComboBox_LU.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        self.mMapLayerComboBox_HSG.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        self.mMapLayerComboBox_Int.setFilters(QgsMapLayerProxyModel.PolygonLayer)
        self.mMapLayerComboBox_CN.setFilters(QgsMapLayerProxyModel.PolygonLayer)

        # Create a button group for the download options
        self.downloadButtonGroup = QButtonGroup(self)
        self.downloadButtonGroup.addButton(self.LUandSoilSelectButton)
        self.downloadButtonGroup.addButton(self.SoilSelectButton)
        self.downloadButtonGroup.addButton(self.LUSelectButton)
        self.downloadButtonGroup.setExclusive(True)

        # Create a button group for the area selection options
        self.areaButtonGroup = QButtonGroup(self)
        self.areaButtonGroup.addButton(self.extentButton)
        self.areaButtonGroup.addButton(self.polygonButton)
        self.areaButtonGroup.setExclusive(True)

        # Set default checked states (one must always be checked)
        self.extentButton.setChecked(True)
        self.LUandSoilSelectButton.setChecked(True)

        # Connect toggled signals to your slots
        self.extentButton.toggled.connect(self.toggle_to_extent)
        self.polygonButton.toggled.connect(self.toggle_to_polygon)
        self.LUandSoilSelectButton.toggled.connect(self.toggle_to_LUandSoil)
        self.SoilSelectButton.toggled.connect(self.toggle_to_Soil)
        self.LUSelectButton.toggled.connect(self.toggle_to_LU)

        self.runButton.clicked.connect(self.Download)
        self.abortButton.clicked.connect(self.Abort)
        self.runButton_Int.clicked.connect(self.RunIntersection)

        self.CNButton.clicked.connect(self.RunCN)
        self.CNFileSelect.setFilePath(os.path.normpath(os.path.join(os.path.dirname(__file__), 'config', 'CN_table.csv')))

        self.radioButtonRainRainfall.toggled.connect(self.toggle_to_wps_runoff)
        self.radioButtonUserRainfall.toggled.connect(self.toggle_to_user_runoff)

        self.pushButton_runoff.clicked.connect(self.RunRunOff)

        self.pushButton.clicked.connect(self.openDocs)

        self.task_manager = QgsApplication.taskManager()

    def openDocs(self):
        """Open the documentation in the default browser via Qt."""
        url = QUrl("https://ctu-geoforall-lab.github.io/qgis-czech-lu-cn-analyzer-plugin/")
        QDesktopServices.openUrl(url)
        iface.messageBar().pushMessage(
            "Info:", "Check docs in your browser.", level=Qgis.Info, duration=5
        )
    def Abort(self):
        """Abort the current task."""
        QgsApplication.taskManager().cancelAll()
        self.ui_updater.TaskCanceled()

    def toggle_to_LUandSoil(self):
        self.DownloadFlag = 0

    def toggle_to_LU(self):
        self.DownloadFlag = 1

    def toggle_to_Soil(self):
        self.DownloadFlag = 2

    def toggle_to_extent(self):
        self.AreaFlag = False
        self.ui_updater.ToggleChangeToExtent()

    def toggle_to_polygon(self):
        self.AreaFlag = True
        self.ui_updater.ToggleChangeToPolygon()

    def toggle_to_user_runoff(self):
        self.RunOffFlag = True
        self.ui_updater.ToggleChangeToUserRunoff()

    def toggle_to_wps_runoff(self):
        self.RunOffFlag = False
        self.ui_updater.ToggleChangeToWPSRunoff()

    def closeEvent(self, event):
        """Emit the closingPlugin signal when the dock widget is closed."""
        self.closingPlugin.emit()
        event.accept()

    def Download(self):
        """  """
        if self.DownloadFlag == 0:
            self.Run()
        elif self.DownloadFlag == 1:
            self.Run()
        elif self.DownloadFlag == 2:
            self.RunSoil()

    def Run(self):
        """
        Run the processing of acquiring the Land Use Layer .
        Starts upon clicking the Run button in UI.
        """
        self.SoilFlag = False # Set SoilFlag to False > LandUse processing
        QgsMessageLog.logMessage("Plugin is running - getting Land Use layer.", "CzLandUseCN", level=Qgis.Info, notifyUser=False)

        self.ui_updater.reset_panel() # Reset UI elements

        self.LandUseLayers = [] # List of LandUse layers for merge in the end

        try:
            # Load the polygon layer from the map layer combo box
            if self.AreaFlag: # If AreaFlag is set, get the polygon from the current layer
                self.polygon = self.mMapLayerComboBox.currentLayer()

                if self.polygon is None or not self.polygon.isValid():
                    self.ui_updater.ErrorMsg("Missing or Invalid polygon layer.")
                    self.ui_updater.setButtonstoDefault()
                    QgsMessageLog.logMessage("Missing or Invalid polygon layer.", "CzLandUseCN",
                                             level=Qgis.Critical, notifyUser=False)
                    return None

                try:
                    # disslove the polygon layer for faster processing
                    self.polygon = dissolve_polygon(self.polygon)

                except Exception as e:
                    self.ui_updater.ErrorMsg("Polygon error - check logs")
                    self.ui_updater.setButtonstoDefault()
                    QgsMessageLog.logMessage("Polygon error: " + str(e), "CzLandUseCN",
                                             level=Qgis.Critical, notifyUser=False)
                    return None

            self.ui_updater.LoadingMsg("Loading data, please wait...")
            # Freeze the UI elements during processing
            self.ui_updater.freeze_ui()

            # Get the list of WFS layers to process from merging config file
            config_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "config", "layers_merging_order.csv")

            wfs_downloader = WFSDownloader(config_path,self.AreaFlag, self.polygon, self.SoilFlag)
            # Get info for WFS service input based on extent or polygon
            wfs_layers = wfs_downloader.get_ZABAGED_layers_list() # load WFS layers from config file
            self.ymin, self.xmin, self.ymax, self.xmax, self.extent = wfs_downloader.get_wfs_info(wfs_layers)

            # Check input by user, Qgis project settings and integrity of configuration files

            input_checker = InputChecker(self.polygon, self.ymin, self.xmin, self.ymax, self.xmax, wfs_layers,
                                         QgsProject.instance(), self.mMapLayerComboBox, self.ui_updater, self.AreaFlag,
                                         self.SoilFlag)

            check_list = [input_checker.check_crs() ,input_checker.check_CR_boundary() ,
                          input_checker.check_polygon_layer() ,input_checker.check_wfs_errors(),
                          input_checker.check_size_of_Area()]

            if not all(check_list):  # If any of the checks failed, return None
                QgsMessageLog.logMessage("Invalid Input.", "CzLandUseCN",
                                         level=Qgis.Critical, notifyUser=True)

                return None

            self.progressBar.setEnabled(True)

            # Create a task to process WFS layers
            task = TASK_process_wfs_layer(wfs_layers, self.ymin, self.xmin, self.ymax, self.xmax, self.extent,
                                          self.polygon, self.AreaFlag,
                                          self.label, self.progressBar, self.runButton, self.abortButton,
                                          self.polygonButton, self.extentButton, self.LandUseLayers)


            # Connect signals from Task to update the progress bar and handle task completion
            task.progressChanged.connect(self.ui_updater.updateProgressBar)
            task.taskFinished.connect(self.TaskFinished)
            task.taskCanceled.connect(self.ui_updater.TaskCanceled)
            task.taskError.connect(self.ui_updater.TaskError)

            self.task_manager.addTask(task)

            QgsMessageLog.logMessage("Land Use (WFS) task created.", "CzLandUseCN",
                                     level=Qgis.Info, notifyUser=False)
            return None

        except Exception as e:
            if (len(str(e))) == 0:
                e = "Extent is out of Czech Republic boundaries"
            QgsMessageLog.logMessage(e,"CzLandUseCN",
                                     level=Qgis.Critical, notifyUser=True)
            self.ui_updater.ErrorMsg(f"Error occurred: {e}")
            self.ui_updater.setButtonstoDefault()
            return None

    def TaskFinished_edit(self, layer):
        """Handle task completion for editing layers."""
        self.merged_layer = layer[0]
        # Add the layer to the QGIS project
        QgsProject.instance().addMapLayer(self.merged_layer)

        # Set the filter to only show polygon layers (also reloads the layers from project)
        self.mMapLayerComboBox_LU.setFilters(QgsMapLayerProxyModel.PolygonLayer)

        # Ensure the combo box updates and selects the new layer
        if self.merged_layer and self.merged_layer.id():
            self.mMapLayerComboBox_LU.setLayer(self.merged_layer)
        else:
            QgsMessageLog.logMessage("Failed to add merged layer to ComboBox", "CzLandUseCN", level=Qgis.Warning)

        if self.DownloadFlag == 0:
            # Download Soil layer if both LandUse and Soil are selected
            self.RunSoil()
        else:
            # Show success in the UI elements after completion if only LandUse is selected
            self.ui_updater.PluginSuccess()

    def TaskFinished(self, layers):
        """Handle task completion(WFStask) and update LandUseLayers."""
        self.LandUseLayers = layers

        self.ui_updater.TaskSuccess()

        # Get the path to the config file with base LandUse codes and keywords for zabaged layers
        attribute_template_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "config",
                                               "zabaged_to_LandUseCode_table.yaml")

        # Get the path to the config file for ZABAGED data
        ZABAGED_config_path = os.path.join(os.path.dirname(__file__), 'config', 'ZABAGED.yaml')
        LPIS_config_path = os.path.join(os.path.dirname(__file__), 'config', 'LPIS.yaml')
        stacking_template_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "config",
                                              "layers_merging_order.csv")
        # Get a symbology (.sld) path for the final stacked layer
        symbology_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "colortables", "landuse.sld")

        # Create a task to process Soil layers
        task = TASK_edit_layers(attribute_template_path, LPIS_config_path, ZABAGED_config_path, stacking_template_path,
                 symbology_path, self.AreaFlag, self.polygon, self.ymin, self.xmin, self.ymax, self.xmax,
                                self.progressBar, self.abortButton, self.LandUseLayers)

        # Connect signals from Task to update the progress bar and handle task completion
        task.progressChanged_edit.connect(self.ui_updater.updateProgressBar)
        task.taskFinished_edit.connect(self.TaskFinished_edit)
        task.taskCanceled_edit.connect(self.ui_updater.TaskCanceled)
        task.taskError_edit.connect(self.ui_updater.TaskError)

        # Add task to the task manager
        self.task_manager.addTask(task)

        QgsMessageLog.logMessage("Layer editing task created.", "CzLandUseCN",
                                 level=Qgis.Info, notifyUser=False)
        return None

    def TaskFinished_Soil(self, SoilLayer_Path):
        """Handle task completion for Soil layers."""

        SoilLayer = QgsVectorLayer(SoilLayer_Path, "Soil Layer", "ogr")

        # Clip the layer by polygon that is not buffered
        clipped_soil_layer = simple_clip(SoilLayer,self.not_buffered_plg)

        # Add HSG attribute to the area defining polygon and use it as underline layer for water bodies
        self.not_buffered_plg = add_constant_atr(self.not_buffered_plg, "HSG", 0)

        # Clip the water bodies layer to the polygon by the soil layer
        self.not_buffered_plg = apply_simple_difference(self.not_buffered_plg, clipped_soil_layer)

        # Merge the clipped soil layer with the polygon that is not buffered
        clipped_soil_layer = merge_layers([self.not_buffered_plg,clipped_soil_layer],"Soil Layer HSG")
        style_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "colortables", "soil.sld")
        clipped_soil_layer.loadSldStyle(style_path)

        self.mMapLayerComboBox_HSG.setLayer(QgsProject.instance().addMapLayer(clipped_soil_layer))

        if self.reset_AreaFlag: # If created polygon from extent, reset the AreaFlag
            self.AreaFlag = False

        # Show success in the UI elements after completion
        self.ui_updater.PluginSuccess()

    def RunSoil(self):
        """
        Run the processing of acquiring the Soil Layer .
        Starts upon clicking finishing the Run method (DownloadFlag == 0).
        Or upon clicking the Download button in UI (DownloadFlag == 2).
        """

        self.reset_AreaFlag = False

        if self.DownloadFlag == 2: # If creating only soil layer, get the polygon from the current layer
            if self.AreaFlag:
                self.polygon = self.mMapLayerComboBox.currentLayer()
            else:
                extent = iface.mapCanvas().extent()
                self.ymin, self.xmin, self.ymax, self.xmax =(extent.yMinimum(), extent.xMinimum(), extent.yMaximum(),
                                                             extent.xMaximum())

        # Reset the UI elements and freeze them
        self.ui_updater.reset_panel()
        self.ui_updater.freeze_ui()

        self.label.setText("Downloading Soil Types layer...")

        # If computing in extent mode, get the polygon from the extent
        if not self.AreaFlag:
            self.polygon = get_polygon_from_extent(self.ymin, self.xmin, self.ymax, self.xmax)
            self.AreaFlag = True
            self.reset_AreaFlag = True

        else:
            try:
                if not isinstance(self.polygon, QgsVectorLayer) or not self.polygon.isValid():
                    raise ValueError("Invalid polygon layer")

                # If using the polygon layer from download ComboBox, dissolve it
                self.polygon = dissolve_polygon(self.polygon)

            except Exception as e:
              QgsMessageLog.logMessage(f"Error in RunSoil: {str(e)}", "CzLandUseCN", level=Qgis.Critical)

        if self.DownloadFlag == 2:
            # Get extent from the polygon layer if computing only Soil
            wfs_downloader = WFSDownloader(None, True, self.polygon, self.SoilFlag)

            self.ymin, self.xmin, self.ymax, self.xmax, self.extent = wfs_downloader.get_wfs_info(self.polygon)


        self.SoilFlag = True  # Set SoilFlag to True > Soil type processing

        QgsMessageLog.logMessage("Plugin is running - getting Soil Types layer.", "CzLandUseCN",
                                 level=Qgis.Info, notifyUser=False)

        self.not_buffered_plg = self.polygon # Store the polygon that is not buffered for clipping after buffering
        try:

            # Buffer the polygon by 40m (to avoid missing edges)
            self.polygon = buffer_QgsVectorLayer(self.polygon, 25)


            # Check input by user, Qgis project settings and integrity of configuration files
            input_checker = InputChecker(self.polygon, self.ymin, self.xmin, self.ymax, self.xmax, None,
                                         QgsProject.instance(), self.mMapLayerComboBox, self.ui_updater, self.AreaFlag,
                                         self.SoilFlag)


            check_list = [input_checker.check_crs(), input_checker.check_CR_boundary(), input_checker.check_polygon_layer(),
                          input_checker.check_size_of_Area()]

            if not all(check_list):
                QgsMessageLog.logMessage("Invalid Input.", "CzLandUseCN",
                                 level=Qgis.Critical, notifyUser=True)
                self.ui_updater.TaskError_Soil()
                return None

            # Create a task to process Soil layers
            task = TASK_process_soil_layer(self.polygon, self.ymin, self.xmin, self.ymax, self.xmax,
                                           self.extent, self.label, self.progressBar, self.runButton,
                                           self.abortButton)

            # Connect signals from Task to update the progress bar and handle task completion
            task.progressChanged_Soil.connect(self.ui_updater.updateProgressBar)
            task.taskFinished_Soil.connect(self.TaskFinished_Soil)
            task.taskCanceled_Soil.connect(self.ui_updater.TaskCanceled_Soil)
            task.taskError_Soil.connect(self.ui_updater.TaskError_Soil)

            # Add task to the task manager
            self.task_manager.addTask(task)

            QgsMessageLog.logMessage("Soil task created.", "CzLandUseCN",
                                     level=Qgis.Info, notifyUser=False)
            return None

        except Exception as e:
            if self.reset_AreaFlag:  # If created polygon from extent, reset the AreaFlag
                self.AreaFlag = False

            if (len(str(e))) == 0:
                e = "Extent is out of Czech Republic boundaries"
            QgsMessageLog.logMessage(e, "CzLandUseCN",
                                     level=Qgis.Critical, notifyUser=True)
            self.ui_updater.ErrorMsg(f"Error occurred: {e}")
            self.ui_updater.TaskError_Soil()
            return None

    def taskFinished_Intersection(self, layer):
        """Handle task completion for Intersection layers."""
        layer = layer[0]
        self.mMapLayerComboBox_Int.setLayer(QgsProject.instance().addMapLayer(layer))
        iface.messageBar().clearWidgets()
        iface.messageBar().pushMessage("Success", "Task completed successfully", level=Qgis.Success, duration=5)

    def RunIntersection(self):
        """
        Run the processing of acquiring the Intersection Layer .
        Starts upon clicking the Run button in UI.
        """

        QgsMessageLog.logMessage("Getting Intersection layer.", "CzLandUseCN",
                                 level=Qgis.Info, notifyUser=False)

        # Get the Soil and Land Use layers from the ComboBoxes
        Soil_layer = self.mMapLayerComboBox_HSG.currentLayer()
        LandUse_layer = self.mMapLayerComboBox_LU.currentLayer()

        # Check if the layers are valid and contain the required attributes
        if Soil_layer is None or LandUse_layer is None or not  Soil_layer.isValid() or not LandUse_layer.isValid():
            self.ui_updater.ErrorMsg("Please select both valid Soil and Land Use layers.")
            return None

        if  Soil_layer.fields().indexFromName("HSG") == -1 :
            self.ui_updater.ErrorMsg("HSG layer does not contain HSG attribute.")
            return None

        if LandUse_layer.fields().indexFromName("LandUse_code") == -1 :
            self.ui_updater.ErrorMsg("LandUse layer does not contain LandUse_code attribute.")
            return None

        # Check if the layers overlap
        if overlap_check(Soil_layer, LandUse_layer) is False:
            self.ui_updater.ErrorMsg("Soil and Land Use layers do not overlap.")
            return None

        # Start the Intersection Task
        self.runButton_Int.setEnabled(False)
        self.ui_updater.LoadingMsg("Intersecting Layers, please wait...")

        try:
            # Create a task to process the intersection of Soil and Land Use layers
            task = TASK_Intersection(Soil_layer, LandUse_layer, self.mMapLayerComboBox_Int, self.runButton_Int)
            task.taskFinished_Intersection.connect(self.taskFinished_Intersection)

            # Add task to manager and retry if it fails
            self.task_manager.addTask(task)

        except Exception as e:
            if self.reset_AreaFlag:  # If created polygon from extent, reset the AreaFlag
                self.AreaFlag = False
            self.mMapLayerComboBox_Int.setEnabled(True)
            iface.messageBar().clearWidgets()
            self.ui_updater.ErrorMsg(f"Error occurred: {e}")
            QgsMessageLog.logMessage(f"Error in RunIntersection: {str(e)}", "CzLandUseCN", level=Qgis.Critical)

    def taskFinished_CN(self, layerlist):
        """Handle task completion for CN layer."""
        layer = layerlist[0]

        self.CNButton.setEnabled(True)
        iface.messageBar().clearWidgets()

        layer.setName("CN Layer")
        # Apply the symbology to the CN layer


        self.mMapLayerComboBox_CN.setLayer(QgsProject.instance().addMapLayer(layer))
        iface.messageBar().pushMessage("Success", "Task completed successfully", level=Qgis.Success, duration=5)


    def RunCN(self):
        """
        Run the processing of acquiring the CN Layer .
        Starts upon clicking the Run button in UI.
        """

        QgsMessageLog.logMessage("Getting CN layer.", "CzLandUseCN",
                                 level=Qgis.Info, notifyUser=False)

        IntLayer = self.mMapLayerComboBox_Int.currentLayer()

        if IntLayer.fields().indexFromName("HSG") == -1 or IntLayer.fields().indexFromName("LandUse_code") == -1:
            self.ui_updater.ErrorMsg("Intersection layer does not contain HSG or LandUse_code attribute.")
            QgsMessageLog.logMessage("Intersection layer does not contain HSG or LandUse_code attribute.",
                                     "CzLandUseCN", level=Qgis.Critical)
            return None

        CN_table_path = self.CNFileSelect.filePath()

        if not os.path.exists(CN_table_path):
            self.ui_updater.ErrorMsg("CN table file does not exist.")
            QgsMessageLog.logMessage("CN table file does not exist.", "CzLandUseCN", level=Qgis.Critical)
            return None

        # Check if the CN table file is valid
        if not is_valid_cn_csv(CN_table_path):
            self.ui_updater.ErrorMsg("CN table file is not valid.")
            QgsMessageLog.logMessage("CN table file is not valid.", "CzLandUseCN", level=Qgis.Critical)
            return None

        self.CNButton.setEnabled(False)
        self.ui_updater.LoadingMsg("Creating CN Layer, please wait...")

        try:
            # Create a task to process the intersection of Soil and Land Use layers
            task = TASK_CN(IntLayer, CN_table_path)
            task.taskFinished_CN.connect(self.taskFinished_CN)

            # Add task to manager and retry if it fails
            self.task_manager.addTask(task)

        except Exception as e:
            self.CNButton.setEnabled(True)
            iface.messageBar().clearWidgets()
            self.ui_updater.ErrorMsg(f"Error occurred: {e}")

    def taskFinished_RunOff(self, RunOffLayer):
        """Handle task completion for RunOff layer."""
        iface.messageBar().clearWidgets()
        QgsMessageLog.logMessage("RunOff layer created.", "CzLandUseCN", level=Qgis.Info, notifyUser=False)

        # Add the RunOff layer to the QGIS project
        RunOffLayer = RunOffLayer[0]
        RunOffLayer.setName("RunOff Layer")
        QgsProject.instance().addMapLayer(RunOffLayer)
        self.pushButton_runoff.setEnabled(True)
        self.runoffLabel.setText("Success!")

    def taskError_RunOff(self):
        iface.messageBar().clearWidgets()
        self.pushButton_runoff.setEnabled(True)
        self.runoffLabel.setText("ERROR - check the message log.")
        self.ui_updater.ErrorMsg("Error occurred during RunOff task.")

    def RunRunOff(self):

        self.runoffLabel.setText("Computing RunOff ...")

        CN_layer = self.mMapLayerComboBox_CN.currentLayer()

        # Check if the CN layer is valid and contains the required attributes
        if CN_layer.isValid() is False or CN_layer.fields().indexFromName("CN2") == -1:
            self.ui_updater.ErrorMsg("CN layer is not valid.")
            QgsMessageLog.logMessage("CN layer is not valid.", "CzLandUseCN", level=Qgis.Critical)
            return None

        reoccurence_intervals = get_checked_return_periods(self.checkBox_2yr, self.checkBox_5yr, self.checkBox_10yr,
                                                           self.checkBox_20yr, self.checkBox_50yr,
                                                           self.checkBox_100yr)

        # If using WPS - get the checked return periods, If using user input height, get the user input
        if self.RunOffFlag is False:

            user_defined_height = None

        else:
            user_defined_height = self.OwnRainInput.text()

        input_checker = InputChecker(None, None, None, None, None, None,
                                     QgsProject.instance(), None, self.ui_updater, None,
                                     None)
        # Validate the user-defined rainfall depth
        if self.RunOffFlag:
            user_defined_height = input_checker.validate_user_defined_height(user_defined_height)
            if user_defined_height is None:
                self.runoffLabel.setText("")
                return None

        abstr_coeff = self.InitialAbstractionCoeff.text()
        # Validate the user-defined Initial Abstraction Coefficient
        abstr_coeff = input_checker.validate_abstraction_coefficient(abstr_coeff)
        if abstr_coeff is None:
            self.runoffLabel.setText("")
            return None

        # Run the RunOff Task
        self.pushButton_runoff.setEnabled(False)
        self.ui_updater.LoadingMsg("Computing RunOff, please wait...")

        url_conf_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), "config", "WPS_config.yaml")

        try:
            # Create a task to process the CN layer
            task = TASK_RunOff(CN_layer, reoccurence_intervals, self.RunOffFlag, user_defined_height, abstr_coeff,
                               self.runoffLabel, url_conf_path)
            task.taskFinished_RunOff.connect(self.taskFinished_RunOff)
            task.taskError_RunOff.connect(self.taskError_RunOff)

            # Add task to manager and retry if it fails
            self.task_manager.addTask(task)
            return None

        except Exception as e:
            self.pushButton_runoff.setEnabled(True)
            iface.messageBar().clearWidgets()
            self.ui_updater.ErrorMsg(f"Error occurred: {e}")
            self.runoffLabel.setText("ERROR - check the message log.")
            return None